<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="566" />
    <option name="newTranslationDialogX" value="573" />
    <option name="newTranslationDialogY" value="325" />
    <histories>
      <item value="superseded by" />
      <item value="`name` is moved out of person, but `age` is referenced." />
      <item value="naked" />
      <item value="shear" />
      <item value="noise" />
      <item value="varable" />
      <item value="Explicit lifetimes given in parameter types where they could be elided " />
      <item value="Find the sum of all the squared odd numbers under 1000" />
      <item value="translate" />
      <item value="This is your captain speaking." />
      <item value="Wizard" />
      <item value="Pilot" />
      <item value="&amp; denotes that your pattern expects a reference to an object. Hence &amp; is a part of said pattern: &amp;Foo matches different objects than Foo does.&#10;ref indicates that you want a reference to an unpacked value. It is not matched against: Foo(ref foo) matches the same objects as Foo(foo)." />
      <item value="Bind by reference during pattern matching.&#10;ref annotates pattern bindings to make them borrow rather than move. It is not a part of the pattern as far as matching is concerned: it does not affect whether a value is matched, only how it is matched.&#10;By default, match statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:&#10;let maybe_name = Some(String::from(&quot;Alice&quot;));&#10;// The variable 'maybe_name' is consumed here ...&#10;match maybe_name {&#10;    Some(n) =&gt; println!(&quot;Hello, {}&quot;, n),&#10;    _ =&gt; println!(&quot;Hello, world&quot;),&#10;}&#10;// ... and is now unavailable.&#10;println!(&quot;Hello again, {}&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));&#10;&#10;Using the ref keyword, the value is only borrowed, not moved, making it available for use after the match statement:&#10;let maybe_name = Some(String::from(&quot;Alice&quot;));&#10;// Using `ref`, the value is borrowed, not moved ...&#10;match maybe_name {&#10;    Some(ref n) =&gt; println!(&quot;Hello, {}&quot;, n),&#10;    _ =&gt; println!(&quot;Hello, world&quot;),&#10;}&#10;// ... so it's available here!&#10;println!(&quot;Hello again, {}&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));&#10;&#10;&amp; vs ref&#10;&amp; denotes that your pattern expects a reference to an object. Hence &amp; is a part of said pattern: &amp;Foo matches different objects than Foo does.&#10;ref indicates that you want a reference to an unpacked value. It is not matched against: Foo(ref foo) matches the same objects as Foo(foo)" />
      <item value="`ref` on an entire `let` pattern is discouraged, take a reference with `&amp;` instead" />
      <item value="TODO: Implement a missing trait so that `main()` below will compile. It is not necessary to implement any methods inside the missing trait." />
      <item value="1. Implement a missing trait so that `main()` will compile. 2. Complete the partial implementation of `From` for `ParseClimateError`. 3. Handle the missing error cases in the `FromStr` implementation for `Climate`. 4. Complete the partial implementation of `Display` for `ParseClimateError`." />
      <item value="TODO: Complete this function so that it produces the correct strings for each error variant." />
      <item value="The `Display` trait allows for other code to obtain the error formatted as a user-visible string." />
      <item value="This `From` implementation allows the `?` operator to work on `ParseFloatError` values." />
      <item value="This `From` implementation allows the `?` operator to work on `ParseIntError` values." />
      <item value="TODO: Complete this function by making it handle the missing error cases." />
      <item value="Don't change anything below this line (other than to enable ignored tests)." />
      <item value="This exercise demonstrates a few traits that are useful for custom error types to implement, especially so that other code can consume the custom error type more usefully. Make this compile, and make the tests pass! Execute `rustlings hint advanced_errs2` for hints. Steps: 1. Implement a missing trait so that `main()` will compile. 2. Complete the partial implementation of `From` for `ParseClimateError`. 3. Handle the missing error cases in the `FromStr` implementation for `Climate`. 4. Complete the partial implementation of `Display` for `ParseClimateError`." />
      <item value="Climate" />
      <item value="Your task is to complete this implementation and return an Ok result of inner type Color. You need to create an implementation for a tuple of three integers, an array of three integers, and a slice of integers. Note that the implementation for tuple and array will be checked at compile time, but the slice implementation needs to check the slice length! Also note that correct RGB color values must be integers in the 0..=255 range." />
      <item value="xtract the other element from the split operation and parse it into a `usize` as the age" />
      <item value="Extract the first element from the split operation and use it as the name" />
      <item value="Split the given string on the commas present in it" />
      <item value="If the length of the provided string is 0, then return the default of Person" />
      <item value="This function will always block the current thread if there is no data available and it's possible for more data to be sent (at least one sender still exists). Once a message is sent to the corresponding Sender (or SyncSender), this receiver will wake up and return that message.&#10;If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received." />
      <item value="Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up." />
      <item value="In this example, the spawned thread is &quot;detached,&quot; which means that there is no way for the program to learn when the spawned thread completes or otherwise terminates.&#10;To learn when a thread completes, it is necessary to capture the JoinHandle object that is returned by the call to spawn, which provides a join method that allows the caller to wait for the completion of the spawned thread:" />
      <item value="When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a thread (i.e., join)." />
      <item value="Fatal logic errors in Rust cause thread panic, during which a thread will unwind the stack, running destructors and freeing owned resources. While not meant as a 'try/catch' mechanism, panics in Rust can nonetheless be caught (unless compiling with panic=abort) with catch_unwind and recovered from, or alternatively be resumed with resume_unwind. If the panic is not caught the thread will exit, but the panic may optionally be detected from a different thread with join. If the main thread panics without the panic being caught, the application will exit with a non-zero exit" />
      <item value="Communication between threads can be done through channels, Rust's message-passing types, along with other forms of thread synchronization and shared-memory data structures. In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container, Arc." />
      <item value="An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization." />
      <item value="Plugin version: 2.5.0&#10;IDE version: IDEA 2019.3&#10;Operating System and version: Windows 10&#10;Stack Trace: （如果崩溃请提供此项，内容获取方法）" />
      <item value="Native threads. The threading model An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization. Communication between threads can be done through channels, Rust's message-passing types, along with other forms of thread synchronization and shared-memory data structures. In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container, Arc. Fatal logic errors in Rust cause thread panic, during which a thread will unwind the stack, running destructors and freeing owned resources. While not meant as a 'trycatch' mechanism, panics in Rust can nonetheless be caught (unless compiling with panic=abort) with catch_unwind and recovered from, or alternatively be resumed with resume_unwind. If the panic is not caught the thread will exit, but the panic may optionally be detected from a different thread with join. If the main thread panics without the panic being caught, the application will exit with a non-zero exit code. When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a thread (i.e., join). Spawning a thread A new thread can be spawned using the thread::spawn function: use std::thread; thread::spawn(move || { some work here }); In this example, the spawned thread is &quot;detached,&quot; which means that there is no way for the program to learn when the spawned thread completes or otherwise terminates. To learn when a thread completes, it is necessary to capture the JoinHandle object that is returned by the call to spawn, which provides a join method that allows the caller to wait for the completion of the spawned thread: use std::thread; let thread_join_handle = thread::spawn(move || { some work here }); some work here let res = thread_join_handle.join(); The join method returns a thread::Result containing Ok of the final value produced by the spawned thread, or Err of the value given to a call to panic! if the thread panicked. Note that there is no parentchild relationship between a thread that spawns a new thread and the thread being spawned. In particular, the spawned thread may or may not outlive the spawning thread, unless the spawning thread is the main thread. Configuring threads A new thread can be configured before it is spawned via the Builder type, which currently allows you to set the name and stack size for the thread: use std::thread; thread::Builder::new().name(&quot;thread1&quot;.to_string()).spawn(move || { println!(&quot;Hello, world!&quot;); }); The Thread type Threads are represented via the Thread type, which you can get in one of two ways: By spawning a new thread, e.g., using the thread::spawn function, and calling thread on the JoinHandle. By requesting the current thread, using the thread::current function. The thread::current function is available even for threads not spawned by the APIs of this module. Thread-local storage This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized. A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the thread_local! macro and can contain any value that is 'static (no borrowed pointers). It provides an accessor function, with, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of interior mutability through the Cell or RefCell types. Naming threads Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with Builder and pass the desired thread name to Builder::name. To retrieve the thread name from within the thread, use Thread::name. A couple examples of where the name of a thread gets used: If a panic occurs in a named thread, the thread name will be printed in the panic message. The thread name is provided to the OS where applicable (e.g., pthread_setname_np in unix-like platforms). Stack size The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads: Build the thread with Builder and pass the desired stack size to Builder::stack_size. Set the RUST_MIN_STACK environment variable to an integer representing the desired stack size (in bytes). Note that setting Builder::stack_size will override this. Note that the stack size of the main thread is not determined by Rust." />
      <item value="! Native threads. ! ! The threading model ! ! An executing Rust program consists of a collection of native OS threads, ! each with their own stack and local state. Threads can be named, and ! provide some built-in support for low-level synchronization. ! ! Communication between threads can be done through ! [channels], Rust's message-passing types, along with [other forms of thread ! synchronization](....stdsyncindex.html) and shared-memory data ! structures. In particular, types that are guaranteed to be ! threadsafe are easily shared between threads using the ! atomically-reference-counted container, [`Arc`]. ! ! Fatal logic errors in Rust cause thread panic, during which ! a thread will unwind the stack, running destructors and freeing ! owned resources. While not meant as a 'trycatch' mechanism, panics ! in Rust can nonetheless be caught (unless compiling with `panic=abort`) with ! [`catch_unwind`](....stdpanicfn.catch_unwind.html) and recovered ! from, or alternatively be resumed with ! [`resume_unwind`](....stdpanicfn.resume_unwind.html). If the panic ! is not caught the thread will exit, but the panic may optionally be ! detected from a different thread with [`join`]. If the main thread panics ! without the panic being caught, the application will exit with a ! non-zero exit code. ! ! When the main thread of a Rust program terminates, the entire program shuts ! down, even if other threads are still running. However, this module provides ! convenient facilities for automatically waiting for the termination of a ! thread (i.e., join). ! ! Spawning a thread ! ! A new thread can be spawned using the [`thread::spawn`][`spawn`] function: ! ! ```rust ! use std::thread; ! ! thread::spawn(move || { ! some work here ! }); ! ``` ! ! In this example, the spawned thread is &quot;detached,&quot; which means that there is ! no way for the program to learn when the spawned thread completes or otherwise ! terminates. ! ! To learn when a thread completes, it is necessary to capture the [`JoinHandle`] ! object that is returned by the call to [`spawn`], which provides ! a `join` method that allows the caller to wait for the completion of the ! spawned thread: ! ! ```rust ! use std::thread; ! ! let thread_join_handle = thread::spawn(move || { ! some work here ! }); ! some work here ! let res = thread_join_handle.join(); ! ``` ! ! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final ! value produced by the spawned thread, or [`Err`] of the value given to ! a call to [`panic!`] if the thread panicked. ! ! Note that there is no parentchild relationship between a thread that spawns a ! new thread and the thread being spawned. In particular, the spawned thread may or ! may not outlive the spawning thread, unless the spawning thread is the main thread. ! ! Configuring threads ! ! A new thread can be configured before it is spawned via the [`Builder`] type, ! which currently allows you to set the name and stack size for the thread: ! ! ```rust ! ![allow(unused_must_use)] ! use std::thread; ! ! thread::Builder::new().name(&quot;thread1&quot;.to_string()).spawn(move || { ! println!(&quot;Hello, world!&quot;); ! }); ! ``` ! ! The `Thread` type ! ! Threads are represented via the [`Thread`] type, which you can get in one of ! two ways: ! ! By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`] ! function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`]. ! By requesting the current thread, using the [`thread::current`] function. ! ! The [`thread::current`] function is available even for threads not spawned ! by the APIs of this module. ! ! Thread-local storage ! ! This module also provides an implementation of thread-local storage for Rust ! programs. Thread-local storage is a method of storing data into a global ! variable that each thread in the program will have its own copy of. ! Threads do not share this data, so accesses do not need to be synchronized. ! ! A thread-local key owns the value it contains and will destroy the value when the ! thread exits. It is created with the [`thread_local!`] macro and can contain any ! value that is `'static` (no borrowed pointers). It provides an accessor function, ! [`with`], that yields a shared reference to the value to the specified ! closure. Thread-local keys allow only shared access to values, as there would be no ! way to guarantee uniqueness if mutable borrows were allowed. Most values ! will want to make use of some form of interior mutability through the ! [`Cell`] or [`RefCell`] types. ! ! Naming threads ! ! Threads are able to have associated names for identification purposes. By default, spawned ! threads are unnamed. To specify a name for a thread, build the thread with [`Builder`] and pass ! the desired thread name to [`Builder::name`]. To retrieve the thread name from within the ! thread, use [`Thread::name`]. A couple examples of where the name of a thread gets used: ! ! If a panic occurs in a named thread, the thread name will be printed in the panic message. ! The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in ! unix-like platforms). ! ! Stack size ! ! The default stack size for spawned threads is 2 MiB, though this particular stack size is ! subject to change in the future. There are two ways to manually specify the stack size for ! spawned threads: ! ! Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`]. ! Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack ! size (in bytes). Note that setting [`Builder::stack_size`] will override this. ! ! Note that the stack size of the main thread is not determined by Rust. ! ! [channels]: crate::sync::mpsc ! [`join`]: JoinHandle::join ! [`Result`]: crate::result::Result ! [`Ok`]: crate::result::Result::Ok ! [`Err`]: crate::result::Result::Err ! [`thread::current`]: current ! [`thread::Result`]: Result ! [`unpark`]: Thread::unpark ! [`thread::park_timeout`]: park_timeout ! [`Cell`]: crate::cell::Cell ! [`RefCell`]: crate::cell::RefCell ! [`with`]: LocalKey::with" />
      <item value="he threading model ! ! An executing Rust program consists of a collection of native OS threads, ! each with their own stack and local state. Threads can be named, and ! provide some built-in support for low-level synchronization. ! ! Communication between threads can be done through ! [channels], Rust's message-passing types, along with [other forms of thread ! synchronization](....stdsyncindex.html) and shared-memory data ! structures. In particular, types that are guaranteed to be ! threadsafe are easily shared between threads using the ! atomically-reference-counted container, [`Arc`]. ! ! Fatal logic errors in" />
      <item value="'s a vector: {:?}&quot;, v); }); handle.join().unwrap(); }" />
      <item value="spawn" />
      <item value="Native threads.&#10;The threading model&#10;An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization.&#10;Communication between threads can be done through channels, Rust's message-passing types, along with other forms of thread synchronization and shared-memory data structures. In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container, Arc.&#10;Fatal logic errors in Rust cause thread panic, during which a thread will unwind the stack, running destructors and freeing owned resources. While not meant as a 'try/catch' mechanism, panics in Rust can nonetheless be caught (unless compiling with panic=abort) with catch_unwind and recovered from, or alternatively be resumed with resume_unwind. If the panic is not caught the thread will exit, but the panic may optionally be detected from a different thread with join. If the main thread panics without the panic being caught, the application will exit with a non-zero exit code.&#10;When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a thread (i.e., join)." />
      <item value="hi number {} from the spawned thread" />
      <item value="Messenger" />
      <item value="Inspection and manipulation of the process's environment. This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories. There are several functions and structs in this module that have a counterpart ending in os. Those ending in os will return an OsString and those without will return a String." />
      <item value="This consumes the `String` on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new `String` and copying the entire contents on every operation, which would lead to O(n^2) running time when building an n-byte string by repeated concatenation." />
      <item value="Concatenating `&amp;str` slices can be done by converting the first to a `String`:" />
      <item value="If you want to keep using the first `String`, you can clone it and append to the clone instead:" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="161" />
        <entry key="ENGLISH" value="162" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1640755236298" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
  </component>
</application>