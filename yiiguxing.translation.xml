<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="590" />
    <option name="newTranslationDialogX" value="815" />
    <option name="newTranslationDialogY" value="455" />
    <histories>
      <item value="Featching" />
      <item value="truncate" />
      <item value="Normally, here, one would use [`clear`] instead to correctly drop the contents and thus not leak memory." />
      <item value="expect" />
      <item value="Allocator" />
      <item value="variable moved due to use in closure" />
      <item value="to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword" />
      <item value="function requires argument type to outlive `'static`" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function E0373 may outlive borrowed value `name` Note: function requires argument type to outlive `'static` Help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keywor" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function" />
      <item value="作为" />
      <item value="as" />
      <item value="a's" />
      <item value="你好" />
      <item value="hello" />
      <item value="ddd" />
      <item value="fff" />
      <item value="ffffff" />
      <item value="A Universally Unique Identifier (UUID)." />
      <item value="shuffle" />
      <item value="Shuffle a mutable slice in place. For slices of length n, complexity is O(n)." />
      <item value="system clock" />
      <item value="monotonically nondecreasing clock" />
      <item value="measurement" />
      <item value="other time was not earlier than self" />
      <item value="Instant" />
      <item value="// The shared state can only be accessed once the lock is held. // Our non-atomic increment is safe because we're the only thread // which can access the shared state when the lock is held. // // We unwrap() the return value to assert that we are not expecting // threads to ever fail while holding the lock." />
      <item value="// Spawn a few threads to increment a shared variable (non-atomically), and // let the main thread know once all increments are done. // // Here we're using an Arc to share memory among threads, and the data inside // the Arc is protected with a mutex." />
      <item value="spawn" />
      <item value="// Despite dropping gadget_owner, we're still able to print out the name // of the Owner of the Gadgets. This is because we've only dropped the // reference count object, not the Owner it wraps. As long as there are // other `Rc&lt;T&gt;` objects pointing at the same Owner, it will remain // allocated. Notice that the `Rc&lt;T&gt;` wrapper around Gadget.owner gets // automatically dereferenced for us." />
      <item value="Create Gadgets belonging to gadget_owner. To increment the reference" />
      <item value="Create a reference counted Owner." />
      <item value="Constructs a new, empty Vec&lt;T&gt; with the specified capacity. The vector will be able to hold exactly capacity elements without reallocating. If capacity is 0, the vector will not allocate. It is important to note that although the returned vector has the capacity specified, the vector will have a zero length. For an explanation of the difference between length and capacity, see Capacity and reallocation." />
      <item value="Reserves capacity for at least additional more elements to be inserted in the given Vec&lt;T&gt;. The collection may reserve more space to avoid frequent reallocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient." />
      <item value="Square" />
      <item value="method returns a new number and does not mutate the original value" />
      <item value="you probably meant `(self - other).abs()`: \ this operation is `(self - other).max(0.0)` \ except that `abs_sub` also propagates NaNs (also \ known as `fdim` in C). If you truly need the positive \ difference, consider using that expression or the C function \ `fdim`, depending on how you wish to handle NaN (please consider \ filing an issue describing your use-case too)." />
      <item value="Rust's standard collection library provides efficient implementations of the //! most common general purpose programming data structures. By using the //! standard implementations, it should be possible for two libraries to //! communicate without significant data conversion." />
      <item value="over most u" />
      <item value="We sometimes encourage you to keep trying things on a given exercise, // even after you already figured it out. If you got everything working and // feel ready for the next exercise, remove the `I AM NOT DONE` comment below." />
      <item value="Match must be exhaustive" />
      <item value="Calculates the offset from a pointer (convenience for .offset(count as isize)). count is in units of T; e.g., a count of 3 represents a pointer offset of 3 * size_of::&lt;T&gt;() bytes" />
      <item value="cannot be sent between threads safely" />
      <item value="Creates a new asynchronous channel, returning the sender/receiver halves. All data sent on the Sender will become available on the Receiver in the same order as it was sent, and no send will block the calling thread (this channel has an &quot;infinite buffer&quot;, unlike sync_channel, which will block after its buffer limit is reached). recv will block until a message is available. The Sender can be cloned to send to the same channel multiple times, but only one Receiver is supported. If the Receiver is disconnected while trying to send with the Sender, the send method will return a SendError. Similarly, if the Sender is disconnected while trying to recv, the recv method will return a RecvErro" />
      <item value="Waits for the associated thread to finish. In terms of atomic memory orderings, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after join returns. If the child thread panics, Err is returned with the parameter given to panic." />
      <item value="Creates a new Duration from the specified number of milliseconds." />
      <item value="Creates a new Weak pointer to this allocation." />
      <item value="Attempts to upgrade the Weak pointer to an Rc, delaying dropping of the inner value if successful. Returns None if the inner value has since been dropped." />
      <item value="Guard" />
      <item value="// We want to abort on overflow instead of dropping the value. // The reference count will never be zero when this is called; // nevertheless, we insert an abort here to hint LLVM at // an otherwise missed optimization." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="103" />
        <entry key="ENGLISH" value="104" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1635238266064" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
  </component>
</application>