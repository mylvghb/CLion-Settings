<application>
  <component name="AppStorage">
    <histories>
      <item value="divisor" />
      <item value="dividend" />
      <item value="capitalize" />
      <item value="Broken" />
      <item value="// Say we're writing a game where you can buy items with tokens. All items cost // 5 tokens, and whenever you purchase items there is a processing fee of 1 // token. A player of the game will type in how many items they want to buy, // and the `total_cost` function will calculate the total number of tokens. // Since the player typed in the quantity, though, we get it as a string-- and // they might have typed anything, not just numbers! // Right now, this function isn't handling the error case at all (and isn't // handling the success case properly either). What we want to do is: // if we call the `parse` function on a string that is not a number, that // function will return a `ParseIntError`, and in that case, we want to // immediately return that error from our function and not try to multiply // and add. // There are at least two ways to implement this that are both correct-- but // one is a lot shorter! Execute `rustlings hint errors2` for hints to both ways." />
      <item value="// This function refuses to generate text to be printed on a nametag if // you pass it an empty string. It'd be nicer if it explained what the problem // was, instead of just sometimes returning `None`. The 2nd test currently // does not compile or pass, but it illustrates the behavior we would like // this function to have. // Execute `rustlings hint errors1` for hints!" />
      <item value="// Refactor this code so that instead of having `vec0` and creating the vector // in `fn main`, we instead create it within `fn fill_vec` and transfer the // freshly created vector from fill_vec to its caller. // Execute `rustlings hint move_semantics4` for hints!" />
      <item value="semantics" />
      <item value="implement the message variant types based on their usage below" />
      <item value="Creates owned data from borrowed data, usually by cloning." />
      <item value="// Ok, here are a bunch of values-- some are `Strings`, some are `&amp;strs`. Your // task is to call one of these two functions on each value depending on what // you think each value is. That is, add either `string_slice` or `string` // before the parentheses on each line. If you're right, it will compile!" />
      <item value="Ok, here are a bunch of values-- some are `Strings`, some are `&amp;strs`." />
      <item value="The `current_favorite_color` function is currently returning a string slice with the `'static` lifetime. We know this because the data of the string lives in our code itself -- it doesn't come from a file or user input or another program -- so it will live as long as our program lives. But it is still a string slice. There's one way to create a `String` by converting a string slice covered in the Strings chapter of the book, and another way that uses the `From` trait." />
      <item value="measure" />
      <item value="mem" />
      <item value="intrinsics" />
      <item value="The stabilized version of this intrinsic is" />
      <item value="aliasing violations or data races will cause undefined behavior" />
      <item value="found reserved identifier" />
      <item value="`self` cannot be a raw identifier" />
      <item value="On all platforms, the newline is the LINE FEED character (`\n`/`U+000A`) alone /// (no additional CARRIAGE RETURN (`\r`/`U+000D`))." />
      <item value="Prints to the standard output, with a newline." />
      <item value="expected value, found builtin type `i32`" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="20" />
        <entry key="ENGLISH" value="21" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
</application>