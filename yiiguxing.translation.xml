<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="590" />
    <option name="newTranslationDialogX" value="815" />
    <option name="newTranslationDialogY" value="455" />
    <histories>
      <item value="Concatenating `&amp;str` slices can be done by converting the first to a `String`:" />
      <item value="If you want to keep using the first `String`, you can clone it and append to the clone instead:" />
      <item value="Concatenating two `String`s takes the first by value and borrows the second:" />
      <item value="Implements the `+` operator for concatenating two strings. This consumes the `String` on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new `String` and copying the entire contents on every operation, which would lead to O(n^2) running time when building an n-byte string by repeated concatenation. The string on the right-hand side is only borrowed; its contents are copied into the returned `String`." />
      <item value="This has the same behavior as the [`push_str`][String::push_str] method." />
      <item value="Implements the `+=` operator for appending to a `String`." />
      <item value="seasonal" />
      <item value="There is an implicit weak pointer owned by all the strong pointers, which ensures that the weak destructor never frees the allocation while the strong destructor is running, even if the weak pointer is stored inside the strong one." />
      <item value="Reinterprets the bits of a value of one type as another type." />
      <item value="transmute" />
      <item value="exhaustive" />
      <item value="content negotiation" />
      <item value="Decode from string reference as octets. Returns a Result containing a Vec ." />
      <item value="Use Result&lt;T, anyhow::Error&gt;, or equivalently anyhow::Result&lt;T&gt;, as the return type of any fallible function." />
      <item value="This library provides anyhow::Error, a trait object based error type for easy idiomatic error handling in Rust applications." />
      <item value="creates a temporary which is freed while still in use" />
      <item value="temporary value is freed at the end of this stateme" />
      <item value="Performs the conversion." />
      <item value="Featching" />
      <item value="truncate" />
      <item value="Normally, here, one would use [`clear`] instead to correctly drop the contents and thus not leak memory." />
      <item value="expect" />
      <item value="Allocator" />
      <item value="variable moved due to use in closure" />
      <item value="to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword" />
      <item value="function requires argument type to outlive `'static`" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function E0373 may outlive borrowed value `name` Note: function requires argument type to outlive `'static` Help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keywor" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function" />
      <item value="作为" />
      <item value="as" />
      <item value="a's" />
      <item value="你好" />
      <item value="hello" />
      <item value="ddd" />
      <item value="fff" />
      <item value="ffffff" />
      <item value="A Universally Unique Identifier (UUID)." />
      <item value="shuffle" />
      <item value="Shuffle a mutable slice in place. For slices of length n, complexity is O(n)." />
      <item value="system clock" />
      <item value="monotonically nondecreasing clock" />
      <item value="measurement" />
      <item value="other time was not earlier than self" />
      <item value="Instant" />
      <item value="// The shared state can only be accessed once the lock is held. // Our non-atomic increment is safe because we're the only thread // which can access the shared state when the lock is held. // // We unwrap() the return value to assert that we are not expecting // threads to ever fail while holding the lock." />
      <item value="// Spawn a few threads to increment a shared variable (non-atomically), and // let the main thread know once all increments are done. // // Here we're using an Arc to share memory among threads, and the data inside // the Arc is protected with a mutex." />
      <item value="spawn" />
      <item value="// Despite dropping gadget_owner, we're still able to print out the name // of the Owner of the Gadgets. This is because we've only dropped the // reference count object, not the Owner it wraps. As long as there are // other `Rc&lt;T&gt;` objects pointing at the same Owner, it will remain // allocated. Notice that the `Rc&lt;T&gt;` wrapper around Gadget.owner gets // automatically dereferenced for us." />
      <item value="Create Gadgets belonging to gadget_owner. To increment the reference" />
      <item value="Create a reference counted Owner." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="119" />
        <entry key="ENGLISH" value="120" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1637654411072" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
  </component>
</application>