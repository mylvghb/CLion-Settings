<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="564" />
    <option name="newTranslationDialogX" value="573" />
    <option name="newTranslationDialogY" value="325" />
    <histories>
      <item value="Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing." />
      <item value="Wrapping (modular) addition. Computes self + rhs, wrapping around at the boundary of the type." />
      <item value="An iterator over the lines of a string, as string slices. Lines are ended with either a newline (\n) or a carriage return with a line feed (\r\n). The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending." />
      <item value="Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'. The type Rc&lt;T&gt; provides shared ownership of a value of type T, allocated in the heap. Invoking clone on Rc produces a new pointer to the same allocation in the heap. When the last Rc pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped. Shared references in Rust disallow mutation by default, and Rc is no exception: you cannot generally obtain a mutable reference to something inside an Rc. If you need mutability, put a Cell or RefCell inside the Rc; see an example of mutability inside an Rc. Rc uses non-atomic reference counting. This means that overhead is very low, but an Rc cannot be sent between threads, and consequently Rc does not implement Send. As a result, the Rust compiler will check at compile time that you are not sending Rcs between threads. If you need multi-threaded, atomic reference counting, use sync::Arc. The downgrade method can be used to create a non-owning Weak pointer. A Weak pointer can be upgraded to an Rc, but this will return None if the value stored in the allocation has already been dropped. In other words, Weak pointers do not keep the value inside the allocation alive; however, they do keep the allocation (the backing store for the inner value) alive. A cycle between Rc pointers will never be deallocated. For this reason, Weak is used to break cycles. For example, a tree could have strong Rc pointers from parent nodes to children, and Weak pointers from children back to their parents. Rc&lt;T&gt; automatically dereferences to T (via the Deref trait), so you can call T's methods on a value of type Rc&lt;T&gt;. To avoid name clashes with T's methods, the methods of Rc&lt;T&gt; itself are associated functions, called using fully qualified syntax :" />
      <item value="FIXME: Do nothing, drop is currently performed by compiler." />
      <item value="Returns a path that, when joined onto base, yields self." />
      <item value="failed to iterate over archive" />
      <item value="Dice-rolling" />
      <item value="Retrieve the lazily-initialized thread-local random number generator, seeded by the system. Intended to be used in method chaining style, e.g. thread_rng().gen::&lt;i32&gt;(), or cached locally, e.g. let mut rng = thread_rng();. Invoked by the Default trait, making ThreadRng::default() equivalent." />
      <item value="An automatically-implemented extension trait on RngCore providing high-level generic methods for sampling values and other convenience methods. This is the primary trait to use when generating random values. Generic usage The basic pattern is fn foo&lt;R: Rng + ?Sized&gt;(rng: &amp;mut R). Some things are worth noting here: Since Rng: RngCore and every RngCore implements Rng, it makes no difference whether we use R: Rng or R: RngCore. The + ?Sized un-bounding allows functions to be called directly on type-erased references; i.e. foo(r) where r: &amp;mut dyn RngCore. Without this it would be necessary to write foo(&amp;mut r). An alternative pattern is possible: fn foo&lt;R: Rng&gt;(rng: R). This has some trade-offs. It allows the argument to be consumed directly without a &amp;mut (which is how from_rng(thread_rng()) works); also it still works directly on references (including type-erased references). Unfortunately within the function foo it is not known whether rng is a reference type or not, hence many uses of rng require an extra reference, either explicitly (distr.sample(&amp;mut rng)) or implicitly (rng.gen()); one may hope the optimiser can remove redundant references later." />
      <item value="drain" />
      <item value="retain" />
      <item value="superseded by" />
      <item value="`name` is moved out of person, but `age` is referenced." />
      <item value="naked" />
      <item value="shear" />
      <item value="noise" />
      <item value="varable" />
      <item value="Explicit lifetimes given in parameter types where they could be elided " />
      <item value="Find the sum of all the squared odd numbers under 1000" />
      <item value="translate" />
      <item value="This is your captain speaking." />
      <item value="Wizard" />
      <item value="Pilot" />
      <item value="&amp; denotes that your pattern expects a reference to an object. Hence &amp; is a part of said pattern: &amp;Foo matches different objects than Foo does.&#10;ref indicates that you want a reference to an unpacked value. It is not matched against: Foo(ref foo) matches the same objects as Foo(foo)." />
      <item value="Bind by reference during pattern matching.&#10;ref annotates pattern bindings to make them borrow rather than move. It is not a part of the pattern as far as matching is concerned: it does not affect whether a value is matched, only how it is matched.&#10;By default, match statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:&#10;let maybe_name = Some(String::from(&quot;Alice&quot;));&#10;// The variable 'maybe_name' is consumed here ...&#10;match maybe_name {&#10;    Some(n) =&gt; println!(&quot;Hello, {}&quot;, n),&#10;    _ =&gt; println!(&quot;Hello, world&quot;),&#10;}&#10;// ... and is now unavailable.&#10;println!(&quot;Hello again, {}&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));&#10;&#10;Using the ref keyword, the value is only borrowed, not moved, making it available for use after the match statement:&#10;let maybe_name = Some(String::from(&quot;Alice&quot;));&#10;// Using `ref`, the value is borrowed, not moved ...&#10;match maybe_name {&#10;    Some(ref n) =&gt; println!(&quot;Hello, {}&quot;, n),&#10;    _ =&gt; println!(&quot;Hello, world&quot;),&#10;}&#10;// ... so it's available here!&#10;println!(&quot;Hello again, {}&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));&#10;&#10;&amp; vs ref&#10;&amp; denotes that your pattern expects a reference to an object. Hence &amp; is a part of said pattern: &amp;Foo matches different objects than Foo does.&#10;ref indicates that you want a reference to an unpacked value. It is not matched against: Foo(ref foo) matches the same objects as Foo(foo)" />
      <item value="`ref` on an entire `let` pattern is discouraged, take a reference with `&amp;` instead" />
      <item value="TODO: Implement a missing trait so that `main()` below will compile. It is not necessary to implement any methods inside the missing trait." />
      <item value="1. Implement a missing trait so that `main()` will compile. 2. Complete the partial implementation of `From` for `ParseClimateError`. 3. Handle the missing error cases in the `FromStr` implementation for `Climate`. 4. Complete the partial implementation of `Display` for `ParseClimateError`." />
      <item value="TODO: Complete this function so that it produces the correct strings for each error variant." />
      <item value="The `Display` trait allows for other code to obtain the error formatted as a user-visible string." />
      <item value="This `From` implementation allows the `?` operator to work on `ParseFloatError` values." />
      <item value="This `From` implementation allows the `?` operator to work on `ParseIntError` values." />
      <item value="TODO: Complete this function by making it handle the missing error cases." />
      <item value="Don't change anything below this line (other than to enable ignored tests)." />
      <item value="This exercise demonstrates a few traits that are useful for custom error types to implement, especially so that other code can consume the custom error type more usefully. Make this compile, and make the tests pass! Execute `rustlings hint advanced_errs2` for hints. Steps: 1. Implement a missing trait so that `main()` will compile. 2. Complete the partial implementation of `From` for `ParseClimateError`. 3. Handle the missing error cases in the `FromStr` implementation for `Climate`. 4. Complete the partial implementation of `Display` for `ParseClimateError`." />
      <item value="Climate" />
      <item value="Your task is to complete this implementation and return an Ok result of inner type Color. You need to create an implementation for a tuple of three integers, an array of three integers, and a slice of integers. Note that the implementation for tuple and array will be checked at compile time, but the slice implementation needs to check the slice length! Also note that correct RGB color values must be integers in the 0..=255 range." />
      <item value="xtract the other element from the split operation and parse it into a `usize` as the age" />
      <item value="Extract the first element from the split operation and use it as the name" />
      <item value="Split the given string on the commas present in it" />
      <item value="If the length of the provided string is 0, then return the default of Person" />
      <item value="This function will always block the current thread if there is no data available and it's possible for more data to be sent (at least one sender still exists). Once a message is sent to the corresponding Sender (or SyncSender), this receiver will wake up and return that message.&#10;If the corresponding Sender has disconnected, or it disconnects while this call is blocking, this call will wake up and return Err to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received." />
      <item value="Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up." />
      <item value="In this example, the spawned thread is &quot;detached,&quot; which means that there is no way for the program to learn when the spawned thread completes or otherwise terminates.&#10;To learn when a thread completes, it is necessary to capture the JoinHandle object that is returned by the call to spawn, which provides a join method that allows the caller to wait for the completion of the spawned thread:" />
      <item value="When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a thread (i.e., join)." />
      <item value="Fatal logic errors in Rust cause thread panic, during which a thread will unwind the stack, running destructors and freeing owned resources. While not meant as a 'try/catch' mechanism, panics in Rust can nonetheless be caught (unless compiling with panic=abort) with catch_unwind and recovered from, or alternatively be resumed with resume_unwind. If the panic is not caught the thread will exit, but the panic may optionally be detected from a different thread with join. If the main thread panics without the panic being caught, the application will exit with a non-zero exit" />
      <item value="Communication between threads can be done through channels, Rust's message-passing types, along with other forms of thread synchronization and shared-memory data structures. In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container, Arc." />
      <item value="An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization." />
      <item value="Plugin version: 2.5.0&#10;IDE version: IDEA 2019.3&#10;Operating System and version: Windows 10&#10;Stack Trace: （如果崩溃请提供此项，内容获取方法）" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="171" />
        <entry key="ENGLISH" value="167" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1642064648733" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
  </component>
</application>