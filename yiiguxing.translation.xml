<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="560" />
    <option name="newTranslationDialogX" value="573" />
    <option name="newTranslationDialogY" value="325" />
    <histories>
      <item value="This will panic or abort if we would allocate &gt; isize::MAX bytes or if the length increment would overflow for zero-sized types." />
      <item value="transpose" />
      <item value="Shift everything down to fill in that spot." />
      <item value="intrinsic" />
      <item value="We are calling the intrinsics directly to avoid function calls in the generated code as `intrinsics::copy_nonoverlapping` is a wrapper function." />
      <item value="SEVERE" />
      <item value="intrinsics" />
      <item value="Sentinel" />
      <item value="positive" />
      <item value="flips" />
      <item value="simulate" />
      <item value="flip" />
      <item value="Historically this function did not cache keys from the OS and instead simply always called `rand::thread_rng().gen()` twice. In 31356 it was discovered, however, that because we re-seed the thread-local RNG from the OS periodically that this can cause excessive slowdown when many hash maps are created on a thread. To solve this performance trap we cache the first set of randomly generated keys per-thread. Later in 36481 it was discovered that exposing a deterministic iteration order allows a form of DOS attack. To counter that we increment one of the seeds on every RandomState creation, giving every corresponding HashMap a different iteration order." />
      <item value="Waits for the associated thread to finish." />
      <item value="杀杀杀" />
      <item value="hange the type of the numeric literal from `u32` to `i32`" />
      <item value="Failed: can not connect to remote server." />
      <item value="Input original string" />
      <item value="The string that is colored" />
      <item value="The front color of the string" />
      <item value="fundamental" />
      <item value="rustc paren sugar" />
      <item value="The area of the square is" />
      <item value="run it with hyper on localhost:3000" />
      <item value="received" />
      <item value="A barrier enables multiple threads to synchronize the beginning of some computation." />
      <item value="Extracts a handle to the underlying thread" />
      <item value="Let some time pass for the thread to be spawned." />
      <item value="We want to wait until the flag is set. We could just spin, but using parkunpark is more efficient." />
      <item value="detached" />
      <item value="we retain our original value of 2 despite the child thread" />
      <item value="wait for the thread to complete and bail out on panic" />
      <item value="each thread starts out with the initial value of 1" />
      <item value="If the join handle is dropped, the spawned thread will implicitly be detached. In this case, the spawned thread may no longer be joined. (It is the responsibility of the program to either eventually join threads it creates or detach them; otherwise, a resource leak will result.)" />
      <item value="Spawns a new thread, returning a JoinHandle for it. The join handle provides a join method that can be used to join the spawned thread. If the spawned thread panics, join will return an Err containing the argument given to panic!. If the join handle is dropped, the spawned thread will implicitly be detached. In this case, the spawned thread may no longer be joined. (It is the responsibility of the program to either eventually join threads it creates or detach them; otherwise, a resource leak will result.) This call will create a thread using default parameters of Builder, if you want to specify the stack size or the name of the thread, use this API instead. As you can see in the signature of spawn there are two constraints on both the closure given to spawn and its return value, let's explain them: The 'static constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we can't know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the 'static lifetime. The Send constraint is because the closure will need to be passed by value from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is joined. As a reminder, the Send marker trait expresses that it is safe to be passed from thread to thread. Sync expresses that it is safe to have a reference be passed from thread to thread." />
      <item value="Retains only the elements specified by the predicate. In other words, remove all elements e such that f(&amp;e) returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements." />
      <item value="retain" />
      <item value="Gadget" />
      <item value="Note: this is an associated function, which means that you have to call it as Box::leak(b) instead of b.leak(). This is so that there is no conflict with a method on the inner type." />
      <item value="This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the Box::from_raw function producing a Box. This Box can then be dropped which will properly destroy T and release the allocated memory." />
      <item value="Consumes and leaks the Box, returning a mutable reference, &amp;'a mut T. Note that the type T must outlive the chosen lifetime 'a. If the type has only static references, or none at all, then this may be chosen to be 'static." />
      <item value="Consumes and leaks the Box, returning a mutable reference, &amp;'a mut T. Note that the type T must outlive the chosen lifetime 'a. If the type has only static references, or none at all, then this may be chosen to be 'static. This function is mainly useful for data that lives for the remainder of the program's life. Dropping the returned reference will cause a memory leak. If this is not acceptable, the reference should first be wrapped with the Box::from_raw function producing a Box. This Box can then be dropped which will properly destroy T and release the allocated memory." />
      <item value="consider restricting type parameter `T`" />
      <item value="Raises a number to an integer power. Using this function is generally faster than using powf" />
      <item value="This merge sort borrows some (but not all) ideas from TimSort, which is described in detail" />
      <item value="The join handle provides a join method that can be used to join the spawned thread. If the spawned thread panics, join will return an Err containing the argument given to panic!." />
      <item value="Spawns a new thread, returning a JoinHandle for it." />
      <item value="Spawns a new thread, returning a JoinHandle for it. The join handle provides a join method that can be used to join the spawned thread. If the spawned thread panics, join will return an Err containing the argument given to panic!. If the join handle is dropped, the spawned thread will implicitly be detached. In this case, the spawned thread may no longer be joined. (It is the responsibility of the program to either eventually join threads it creates or detach them; otherwise, a resource leak will result.) This call will create a thread using default parameters of Builder, if you want to specify the stack size or the name of the thread, use this API instead. As you can see in the signature of spawn there are two constraints on both the closure given to spawn and its return value, let's explain them:" />
      <item value="tail" />
      <item value="Returns an iterator over the chars of a string slice, and their positions. As a string slice consists of valid UTF-8, we can iterate through a string slice by char. This method returns an iterator of both these chars, as well as their byte positions. The iterator yields tuples. The position is first, the char is second." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="199" />
        <entry key="ENGLISH" value="200" />
        <entry key="FRENCH" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1655101904288" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
      </google-translate>
    </option>
    <option name="translateDocumentation" value="true" />
  </component>
</application>