<application>
  <component name="AppStorage">
    <histories>
      <item value="Guard" />
      <item value="// We want to abort on overflow instead of dropping the value. // The reference count will never be zero when this is called; // nevertheless, we insert an abort here to hint LLVM at // an otherwise missed optimization." />
      <item value="Makes a clone of the Rc pointer. This creates another pointer to the same allocation, increasing the strong reference count." />
      <item value="situps" />
      <item value="pushups" />
      <item value="match indices" />
      <item value="matches of a pattern within this string slice as well as the index that the match starts at." />
      <item value="case sensitive" />
      <item value="sensitive" />
      <item value="specifier" />
      <item value="remainder" />
      <item value="remind" />
      <item value="crash and burn" />
      <item value="Creates an iterator which can use peek to look at the next element of the iterator without consuming it. Adds a peek method to an iterator. See its documentation for more information. Note that the underlying iterator is still advanced when peek is called for the first time: In order to retrieve the next element, next is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the next method will occur." />
      <item value="peekable" />
      <item value="overlapping patterns" />
      <item value="take order" />
      <item value="server order" />
      <item value="take paymen" />
      <item value="seat at table" />
      <item value="dimensions" />
      <item value="Detects boolean expressions that can be safely simplified like a || true. Does not simplify expressions if some side effects can be eliminated, such as return || true for example." />
      <item value="Detects unnecessary mut qualifiers. This inspection can report false positives and is disabled by default." />
      <item value="Some unstable experimental checks which are disabled by default." />
      <item value="stack backtrace" />
      <item value="Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace" />
      <item value="verbose" />
      <item value="before change" />
      <item value="change before" />
      <item value="expect" />
      <item value="micros" />
      <item value="Transforms an iterator into a collection. collect() can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts. The most basic pattern in which collect() is used is to turn one collection into another. You take a collection, call iter on it, do a bunch of transformations, and then collect() at the end. One of the keys to collect()'s power is that many things you might not think of as 'collections' actually are. For example, a String is a collection of chars. And a collection of Result&lt;T, E&gt; can be thought of as single Result&lt;Collection&lt;T&gt;, E&gt;. See the examples below for more. Because collect() is so general, it can cause problems with type inference. As such, collect() is one of the few times you'll see the syntax affectionately known as the 'turbofish': ::&lt;&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into." />
      <item value="Creates an iterator that works like map, but flattens nested structure. The map adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. flat_map() will remove this extra layer on its own. You can think of flat_map(f) as the semantic equivalent of mapping, and then flattening as in map(f).flatten(). Another way of thinking about flat_map(): map's closure returns one item for each element, and flat_map()'s closure returns an iterator for each element." />
      <item value="Calls a closure on each element of an iterator. This is equivalent to using a for loop on the iterator, although break and continue are not possible from a closure. It's generally more idiomatic to use a for loop, but for_each may be more legible when processing items at the end of longer iterator chains. In some cases for_each may also be faster than a loop, because it will use internal iteration on adaptors like Chain." />
      <item value="cannot find derive macro `Deserialize` in this scope" />
      <item value="Measures the time needed to execute a block of code." />
      <item value="alphabetic" />
      <item value="variant is never constructed: `Four`" />
      <item value="Returns the square root of a number." />
      <item value="sqrt" />
      <item value="closure is `FnOnce` because it moves the variable `a` out of its environment" />
      <item value="/// The version of the call operator that takes an immutable receiver. /// /// Instances of `Fn` can be called repeatedly without mutating state. /// /// *This trait (`Fn`) is not to be confused with [function pointers] /// (`fn`).* /// /// `Fn` is implemented automatically by closures which only take immutable /// references to captured variables or don't capture anything at all, as well /// as (safe) [function pointers] (with some caveats, see their documentation /// for more details). Additionally, for any type `F` that implements `Fn`, `&amp;F` /// implements `Fn`, too. /// /// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any /// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`] /// is expected. /// /// Use `Fn` as a bound when you want to accept a parameter of function-like /// type and need to call it repeatedly and without mutating state (e.g., when /// calling it concurrently). If you do not need such strict requirements, use /// [`FnMut`] or [`FnOnce`] as bounds. /// /// See the [chapter on closures in *The Rust Programming Language*][book] for /// some more information on this topic. /// /// Also of note is the special syntax for `Fn` traits (e.g. /// `Fn(usize, bool) -&gt; usize`). Those interested in the technical details of /// this can refer to [the relevant section in the *Rustonomicon*][nomicon]. ///" />
      <item value="rate limit amount" />
      <item value="rate limit interval seconds" />
      <item value="user understands that enabling tabnine cloud sends code to tabnine servers" />
      <item value="ignore all lsp" />
      <item value="hide promotional message" />
      <item value="tubofish" />
      <item value="associated" />
      <item value="The multiplication operator *. Note that Rhs is Self by default, but this is not mandatory." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="57" />
        <entry key="ENGLISH" value="58" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>