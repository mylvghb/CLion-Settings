<application>
  <component name="AppStorage">
    <histories>
      <item value="Reserves capacity for at least additional more elements to be inserted in the given Vec&lt;T&gt;. The collection may reserve more space to avoid frequent reallocations. After calling reserve, capacity will be greater than or equal to self.len() + additional. Does nothing if capacity is already sufficient." />
      <item value="Square" />
      <item value="method returns a new number and does not mutate the original value" />
      <item value="you probably meant `(self - other).abs()`: \ this operation is `(self - other).max(0.0)` \ except that `abs_sub` also propagates NaNs (also \ known as `fdim` in C). If you truly need the positive \ difference, consider using that expression or the C function \ `fdim`, depending on how you wish to handle NaN (please consider \ filing an issue describing your use-case too)." />
      <item value="Rust's standard collection library provides efficient implementations of the //! most common general purpose programming data structures. By using the //! standard implementations, it should be possible for two libraries to //! communicate without significant data conversion." />
      <item value="over most u" />
      <item value="We sometimes encourage you to keep trying things on a given exercise, // even after you already figured it out. If you got everything working and // feel ready for the next exercise, remove the `I AM NOT DONE` comment below." />
      <item value="Match must be exhaustive" />
      <item value="Calculates the offset from a pointer (convenience for .offset(count as isize)). count is in units of T; e.g., a count of 3 represents a pointer offset of 3 * size_of::&lt;T&gt;() bytes" />
      <item value="cannot be sent between threads safely" />
      <item value="Creates a new asynchronous channel, returning the sender/receiver halves. All data sent on the Sender will become available on the Receiver in the same order as it was sent, and no send will block the calling thread (this channel has an &quot;infinite buffer&quot;, unlike sync_channel, which will block after its buffer limit is reached). recv will block until a message is available. The Sender can be cloned to send to the same channel multiple times, but only one Receiver is supported. If the Receiver is disconnected while trying to send with the Sender, the send method will return a SendError. Similarly, if the Sender is disconnected while trying to recv, the recv method will return a RecvErro" />
      <item value="variable moved due to use in closure" />
      <item value="Waits for the associated thread to finish. In terms of atomic memory orderings, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after join returns. If the child thread panics, Err is returned with the parameter given to panic." />
      <item value="Creates a new Duration from the specified number of milliseconds." />
      <item value="Creates a new Weak pointer to this allocation." />
      <item value="Attempts to upgrade the Weak pointer to an Rc, delaying dropping of the inner value if successful. Returns None if the inner value has since been dropped." />
      <item value="Guard" />
      <item value="// We want to abort on overflow instead of dropping the value. // The reference count will never be zero when this is called; // nevertheless, we insert an abort here to hint LLVM at // an otherwise missed optimization." />
      <item value="Makes a clone of the Rc pointer. This creates another pointer to the same allocation, increasing the strong reference count." />
      <item value="situps" />
      <item value="pushups" />
      <item value="match indices" />
      <item value="matches of a pattern within this string slice as well as the index that the match starts at." />
      <item value="case sensitive" />
      <item value="sensitive" />
      <item value="specifier" />
      <item value="remainder" />
      <item value="remind" />
      <item value="crash and burn" />
      <item value="Creates an iterator which can use peek to look at the next element of the iterator without consuming it. Adds a peek method to an iterator. See its documentation for more information. Note that the underlying iterator is still advanced when peek is called for the first time: In order to retrieve the next element, next is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the next method will occur." />
      <item value="peekable" />
      <item value="overlapping patterns" />
      <item value="take order" />
      <item value="server order" />
      <item value="take paymen" />
      <item value="seat at table" />
      <item value="dimensions" />
      <item value="Detects boolean expressions that can be safely simplified like a || true. Does not simplify expressions if some side effects can be eliminated, such as return || true for example." />
      <item value="Detects unnecessary mut qualifiers. This inspection can report false positives and is disabled by default." />
      <item value="Some unstable experimental checks which are disabled by default." />
      <item value="stack backtrace" />
      <item value="Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace" />
      <item value="verbose" />
      <item value="before change" />
      <item value="change before" />
      <item value="expect" />
      <item value="micros" />
      <item value="Transforms an iterator into a collection. collect() can take anything iterable, and turn it into a relevant collection. This is one of the more powerful methods in the standard library, used in a variety of contexts. The most basic pattern in which collect() is used is to turn one collection into another. You take a collection, call iter on it, do a bunch of transformations, and then collect() at the end. One of the keys to collect()'s power is that many things you might not think of as 'collections' actually are. For example, a String is a collection of chars. And a collection of Result&lt;T, E&gt; can be thought of as single Result&lt;Collection&lt;T&gt;, E&gt;. See the examples below for more. Because collect() is so general, it can cause problems with type inference. As such, collect() is one of the few times you'll see the syntax affectionately known as the 'turbofish': ::&lt;&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into." />
      <item value="Creates an iterator that works like map, but flattens nested structure. The map adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. flat_map() will remove this extra layer on its own. You can think of flat_map(f) as the semantic equivalent of mapping, and then flattening as in map(f).flatten(). Another way of thinking about flat_map(): map's closure returns one item for each element, and flat_map()'s closure returns an iterator for each element." />
      <item value="Calls a closure on each element of an iterator. This is equivalent to using a for loop on the iterator, although break and continue are not possible from a closure. It's generally more idiomatic to use a for loop, but for_each may be more legible when processing items at the end of longer iterator chains. In some cases for_each may also be faster than a loop, because it will use internal iteration on adaptors like Chain." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="67" />
        <entry key="ENGLISH" value="67" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
</application>