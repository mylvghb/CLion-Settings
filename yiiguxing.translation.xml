<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="590" />
    <option name="newTranslationDialogX" value="815" />
    <option name="newTranslationDialogY" value="455" />
    <histories>
      <item value="spawn" />
      <item value="hi number {} from the spawned thread" />
      <item value="Messenger" />
      <item value="Inspection and manipulation of the process's environment. This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories. There are several functions and structs in this module that have a counterpart ending in os. Those ending in os will return an OsString and those without will return a String." />
      <item value="This consumes the `String` on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new `String` and copying the entire contents on every operation, which would lead to O(n^2) running time when building an n-byte string by repeated concatenation." />
      <item value="Concatenating `&amp;str` slices can be done by converting the first to a `String`:" />
      <item value="If you want to keep using the first `String`, you can clone it and append to the clone instead:" />
      <item value="Concatenating two `String`s takes the first by value and borrows the second:" />
      <item value="Implements the `+` operator for concatenating two strings. This consumes the `String` on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new `String` and copying the entire contents on every operation, which would lead to O(n^2) running time when building an n-byte string by repeated concatenation. The string on the right-hand side is only borrowed; its contents are copied into the returned `String`." />
      <item value="This has the same behavior as the [`push_str`][String::push_str] method." />
      <item value="Implements the `+=` operator for appending to a `String`." />
      <item value="seasonal" />
      <item value="There is an implicit weak pointer owned by all the strong pointers, which ensures that the weak destructor never frees the allocation while the strong destructor is running, even if the weak pointer is stored inside the strong one." />
      <item value="Reinterprets the bits of a value of one type as another type." />
      <item value="transmute" />
      <item value="exhaustive" />
      <item value="content negotiation" />
      <item value="Decode from string reference as octets. Returns a Result containing a Vec ." />
      <item value="Use Result&lt;T, anyhow::Error&gt;, or equivalently anyhow::Result&lt;T&gt;, as the return type of any fallible function." />
      <item value="This library provides anyhow::Error, a trait object based error type for easy idiomatic error handling in Rust applications." />
      <item value="creates a temporary which is freed while still in use" />
      <item value="temporary value is freed at the end of this stateme" />
      <item value="Performs the conversion." />
      <item value="Featching" />
      <item value="truncate" />
      <item value="Normally, here, one would use [`clear`] instead to correctly drop the contents and thus not leak memory." />
      <item value="expect" />
      <item value="Allocator" />
      <item value="variable moved due to use in closure" />
      <item value="to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword" />
      <item value="function requires argument type to outlive `'static`" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function E0373 may outlive borrowed value `name` Note: function requires argument type to outlive `'static` Help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keywor" />
      <item value="closure may outlive the current function, but it borrows `name`, which is owned by the current function" />
      <item value="作为" />
      <item value="as" />
      <item value="a's" />
      <item value="你好" />
      <item value="hello" />
      <item value="ddd" />
      <item value="fff" />
      <item value="ffffff" />
      <item value="A Universally Unique Identifier (UUID)." />
      <item value="shuffle" />
      <item value="Shuffle a mutable slice in place. For slices of length n, complexity is O(n)." />
      <item value="system clock" />
      <item value="monotonically nondecreasing clock" />
      <item value="measurement" />
      <item value="other time was not earlier than self" />
      <item value="Instant" />
      <item value="// The shared state can only be accessed once the lock is held. // Our non-atomic increment is safe because we're the only thread // which can access the shared state when the lock is held. // // We unwrap() the return value to assert that we are not expecting // threads to ever fail while holding the lock." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="123" />
        <entry key="ENGLISH" value="124" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1638173547155" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAI5t9Bc63LntXgXBJ1p97w" />
      </app-key>
    </option>
  </component>
</application>